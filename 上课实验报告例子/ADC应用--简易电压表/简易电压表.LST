C51 COMPILER V9.01   简易电压表                                                            05/30/2020 00:23:50 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE 简易电压表
OBJECT MODULE PLACED IN 简易电压表.OBJ
COMPILER INVOKED BY: D:\Keli\C51\BIN\C51.EXE 简易电压表.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include<reg52.h>        
   2          #include <intrins.h> 
   3          typedef unsigned char uchar;
   4          
   5          #define    AddWr 0x90        //PCF8591 地址
   6          
   7          sbit en = P3 ^ 4;           //lcd1602写数据
   8          sbit rs = P3 ^ 5;           //lcd1602写指令
   9          sbit scl=P2^0;             //I2C    时钟 
  10          sbit sda=P2^1;             //I2C    数据 
  11          bit ack;                   //应答标志位
  12          
  13          unsigned char date;
  14          sbit C1=P2^6;//数码管1
  15          sbit C2=P2^7;//数码管2
  16          sbit Dp=P2^5;//小数点
  17          uchar code table[] =
  18          {
  19              "0123456789."
  20          };
  21          uchar code table1[] =
  22          {
  23              "SMC1602 0x01..."
  24          };
  25          unsigned int data dis[3]={0x00,0x00,0x00}; 
  26          unsigned int getData;
  27          /*******************************************************************
  28           起动总线函数                             
  29          函数原型: void    Start_I2c();    
  30          功能:         启动I2C总线,即发送I2C起始条件.    
  31          ********************************************************************/
  32          void Start_I2c()
  33          {
  34   1          sda=1;                 /*发送起始条件的数据信号*/
  35   1          _nop_();
  36   1          scl=1;
  37   1          _nop_();                /*起始条件建立时间大于4.7us,延时*/
  38   1          _nop_();
  39   1          _nop_();
  40   1          _nop_();
  41   1          _nop_();        
  42   1          sda=0;                 /*发送起始信号*/
  43   1          _nop_();                /* 起始条件锁定时间大于4μs*/
  44   1          _nop_();
  45   1          _nop_();
  46   1          _nop_();
  47   1          _nop_();             
  48   1          scl=0;             /*钳住I2C总线，准备发送或接收数据 */
  49   1          _nop_();
  50   1          _nop_();
  51   1      }
  52          
  53          /*******************************************************************
  54          结束总线函数                             
  55          函数原型: void    Stop_I2c();    
C51 COMPILER V9.01   简易电压表                                                            05/30/2020 00:23:50 PAGE 2   

  56          功能:         结束I2C总线,即发送I2C结束条件.    
  57          ********************************************************************/
  58          void Stop_I2c()
  59          {
  60   1          sda=0;            /*发送结束条件的数据信号*/
  61   1          _nop_();             /*发送结束条件的时钟信号*/
  62   1          scl=1;            /*结束条件建立时间大于4μs*/
  63   1          _nop_();
  64   1          _nop_();
  65   1          _nop_();
  66   1          _nop_();
  67   1          _nop_();
  68   1          sda=1;            /*发送I2C总线结束信号*/
  69   1          _nop_();
  70   1          _nop_();
  71   1          _nop_();
  72   1          _nop_();
  73   1      }
  74          
  75          /*******************************************************************
  76           字节数据发送函数                             
  77          函数原型: void    I2C_SendByte(UCHAR c);
  78          功能:         将数据c发送出去,可以是地址,也可以是数据,发完后等待应答,并对
  79          此状态位进行操作.(不应答或非应答都使ack=0)         
  80          发送数据正常，ack=1; ack=0表示被控器无应答或损坏。
  81          ********************************************************************/
  82          void I2C_SendByte(unsigned char    c)
  83          {
  84   1          unsigned char    i;
  85   1      
  86   1          for(i=0;i<8;i++)    /*要传送的数据长度为8位*/
  87   1          {
  88   2              if((c<<i)&0x80)sda=1;     /*判断发送位*/
  89   2              else    sda=0;                                
  90   2              _nop_();
  91   2              scl=1;                             /*置时钟线为高，通知被控器开始接收数据位*/
  92   2              _nop_(); 
  93   2              _nop_();                         /*保证时钟高电平周期大于4μs*/
  94   2              _nop_();
  95   2              _nop_();
  96   2              _nop_();                 
  97   2              scl=0; 
  98   2          }
  99   1          _nop_();
 100   1          _nop_();
 101   1          sda=1;                                /*8位发送完后释放数据线，准备接收应答位*/
 102   1          _nop_();
 103   1          _nop_();     
 104   1          scl=1;
 105   1          _nop_();
 106   1          _nop_();
 107   1          _nop_();
 108   1          if(sda==1)ack=0;         
 109   1          else ack=1;                /*判断是否接收到应答信号*/
 110   1          scl=0;
 111   1          _nop_();
 112   1          _nop_();
 113   1      }
 114          
 115          /*******************************************************************
 116           字节数据接收函数                             
 117          函数原型: UCHAR    I2C_RcvByte();
C51 COMPILER V9.01   简易电压表                                                            05/30/2020 00:23:50 PAGE 3   

 118          功能:                用来接收从器件传来的数据,并判断总线错误(不发应答信号)，
 119          发完后请用应答函数应答从机。    
 120          ********************************************************************/        
 121          unsigned char I2C_RcvByte()
 122          {
 123   1          unsigned char    retc=0,i; 
 124   1          sda=1;                                         /*置数据线为输入方式*/
 125   1          for(i=0;i<8;i++)
 126   1          {
 127   2              _nop_();                     
 128   2              scl=0;                                    /*置时钟线为低，准备接收数据位*/
 129   2              _nop_();
 130   2              _nop_();                                 /*时钟低电平周期大于4.7μs*/
 131   2              _nop_();
 132   2              _nop_();
 133   2              _nop_();
 134   2              scl=1;                                    /*置时钟线为高使数据线上数据有效*/
 135   2              _nop_();
 136   2              _nop_();
 137   2              retc=retc<<1;
 138   2              if(sda==1)retc=retc+1;    /*读数据位,接收的数据位放入retc中 */
 139   2              _nop_();
 140   2              _nop_(); 
 141   2          }
 142   1          scl=0;        
 143   1          _nop_();
 144   1          _nop_();
 145   1          return(retc);
 146   1      }
 147          
 148          /********************************************************************
 149           应答子函数
 150          函数原型:    void Ack_I2c(bit a);
 151          功能:            主控器进行应答信号(可以是应答或非应答信号，由位参数a决定)
 152          ********************************************************************/
 153          void Ack_I2c(bit a)
 154          {    
 155   1          if(a==0)sda=0;                            /*在此发出应答或非应答信号 */
 156   1          else sda=1;                             /*0为发出应答，1为非应答信号 */
 157   1          _nop_();
 158   1          _nop_();
 159   1          _nop_();            
 160   1          scl=1;
 161   1          _nop_();
 162   1          _nop_();                                        /*时钟低电平周期大于4μs*/
 163   1          _nop_();
 164   1          _nop_();
 165   1          _nop_();    
 166   1          scl=0;                                         /*清时钟线，住I2C总线以便继续接收*/
 167   1          _nop_();
 168   1          _nop_();        
 169   1      }
 170          
 171          /************************************************************
 172          * 函数名                : Pcf8591_DaConversion
 173          * 函数功能            : PCF8591的输出端输出模拟量
 174          * 输入                    : addr（器件地址），channel（转换通道），value（转换的数值）
 175          * 输出                  : 无
 176          ******************* *****************************************/
 177          bit Pcf8591_DaConversion(unsigned char addr,unsigned char channel,unsigned char Val)
 178          {
 179   1          Start_I2c();                            //启动总线
C51 COMPILER V9.01   简易电压表                                                            05/30/2020 00:23:50 PAGE 4   

 180   1          I2C_SendByte(addr);                        //发送器件地址
 181   1          if(ack==0)return(0);
 182   1          I2C_SendByte(0x40|channel);                            //发送控制字节
 183   1          if(ack==0)return(0);
 184   1          I2C_SendByte(Val);                        //发送DAC的数值    
 185   1          if(ack==0)return(0);
 186   1          Stop_I2c();                             //结束总线
 187   1          return(1);
 188   1      }
 189          
 190          /************************************************************
 191          * 函数名                : Pcf8591_SendByte
 192          * 函数功能                      : 写入一个控制命令
 193          * 输入                  : addr（器件地址），channel（转换通道）
 194          * 输出                  : 无
 195          ************************************************************/
 196          bit PCF8591_SendByte(unsigned char addr,unsigned char channel)
 197          {
 198   1          Start_I2c();                            //启动总线
 199   1          I2C_SendByte(addr);                        //发送器件地址
 200   1          if(ack==0)return(0);
 201   1          I2C_SendByte(0x40|channel);                            //发送控制字节
 202   1          if(ack==0)return(0);
 203   1          Stop_I2c();                             //结束总线
 204   1          return(1);
 205   1      }
 206          
 207          /************************************************************
 208          * 函数名                : PCF8591_RcvByte
 209          * 函数功能              : 读取一个转换值
 210          * 输入                    :
 211          * 输出                    : dat
 212          ************************************************************/
 213          unsigned char PCF8591_RcvByte(unsigned char addr)
 214          {    
 215   1          unsigned char dat;
 216   1      
 217   1          Start_I2c();                    //启动总线
 218   1          I2C_SendByte(addr+1);            //发送器件地址
 219   1          if(ack==0)return(0);
 220   1          dat=I2C_RcvByte();                    //读取数据0
 221   1      
 222   1          Ack_I2c(1);                     //发送非应答信号
 223   1          Stop_I2c();                     //结束总线
 224   1          return(dat);
 225   1      }
 226          /*------------------------------------------------
 227          串口初始化函数
 228          ------------------------------------------------*/
 229          void init_com(void)
 230          {
 231   1          EA=1;                //开总中断
 232   1          ES=1;                //允许串口中断
 233   1          ET1=1;
 234   1          TMOD=0x22;     //定时器T1，在方式2中断产生波特率
 235   1          PCON=0x00;     //SMOD=0
 236   1          SCON=0x50;     // 方式1 由定时器控制
 237   1          TH1=0xfd;        //波特率设置为9600
 238   1          TL1=0xfd;
 239   1          TR1=1;             //开定时器T1运行控制位
 240   1      }
 241          /*------------------------------------------------
C51 COMPILER V9.01   简易电压表                                                            05/30/2020 00:23:50 PAGE 5   

 242          延时函数
 243          ------------------------------------------------*/
 244          void delay(unsigned char i)
 245          {
 246   1          unsigned char j,k; 
 247   1          for(j=i;j>0;j--)
 248   1          for(k=125;k>0;k--);
 249   1      }
 250          /*------------------------------------------------
 251          把读取值转换成一个一个的字符，给串口显示
 252          ------------------------------------------------*/
 253          void To_ascii(unsigned char num)
 254          {       
 255   1          SBUF=num/100+'0';                        
 256   1          delay(200);             
 257   1          SBUF=num/10%10+'0';                      
 258   1          delay(200); 
 259   1          SBUF=num%10+'0';
 260   1          delay(200);
 261   1      }
 262          /* 写数据 */
 263          void write_date(uchar date)
 264          {
 265   1          //参考写操作时序图
 266   1          rs = 1; //RS高电平,写数据
 267   1          P0 = date; //写入数据,对应时序图t_SP2数据建立
 268   1          delay(5);
 269   1          en = 1; //打开使能,给E一个高脉冲,开始写入数据
 270   1          delay(5);
 271   1          en = 0; //关闭使能,写入数据完成
 272   1      }
 273          /* 写指令 */
 274          void write_com(uchar com)
 275          {
 276   1          //基本原理同写数据
 277   1          rs = 0; //RS低电平,写指令
 278   1          P0 = com;
 279   1          delay(5);
 280   1          en = 1;
 281   1          delay(5);
 282   1          en = 0;
 283   1      }
 284          /* 初始化LCD */
 285          void init_lcd()
 286          {
 287   1          en = 1;
 288   1          write_com(0x38); //00111000 设置16*2显示,5*7点阵,8位数据接口
 289   1          write_com(0x0E); //00001110 开显示,显示光标,不闪烁
 290   1          write_com(0x06); //00000110 读写字符后地址指针+1,光标+1,屏幕不移动
 291   1          write_com(0x01); //清屏
 292   1          write_com(0x80 + 0x01); //设置数据地址指针从第一个开始
 293   1      }
 294          void Display()
 295          {
 296   1          write_date(table[dis[1]]);//整数位
 297   1          delay(20);
 298   1          write_date(table[10]);//小数点
 299   1          delay(20);
 300   1          write_date(table[dis[0]]);//小数位
 301   1          delay(20);
 302   1      }
 303          /*void Display()interrupt 0 using 1
C51 COMPILER V9.01   简易电压表                                                            05/30/2020 00:23:50 PAGE 6   

 304          {
 305              uchar i;
 306              for (i = 0; i < 16; ++i) //遍历逐个写入第一行数据
 307              {
 308                  write_date(table1[i]);
 309                  delay(20);
 310              }
 311          }*/
 312          void Clear()
 313          {
 314   1          write_com(0x01);
 315   1      }
 316          /*------------------------------------------------
 317          主函数
 318          ------------------------------------------------*/
 319          int main()
 320          {    
 321   1          /* 初始化LCD */
 322   1          init_lcd();
 323   1          /* 初始化中断 */
 324   1          EA = 1;
 325   1          EX0 = 1;
 326   1          delay(100);
 327   1          while(1)
 328   1          {
 329   2              PCF8591_SendByte(AddWr,0);       //启动转换
 330   2              getData=PCF8591_RcvByte(AddWr);    //读转换完的数字信号
 331   2      
 332   2              dis[1]=getData/51;     //整数位
 333   2              dis[2]=getData%51;     //dis[2]位中间暂存数据位
 334   2              dis[2]=dis[2]*10;        
 335   2              dis[0]=dis[2]/51;        //计算输出电压的小数值 
 336   2      
 337   2              Clear();                //清屏准备显示新内容
 338   2              Display();              //显示内容
 339   2              delay(300);
 340   2          }
 341   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    543    ----
   CONSTANT SIZE    =     28    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      9    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
