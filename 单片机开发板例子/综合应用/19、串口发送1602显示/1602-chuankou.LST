C51 COMPILER V8.02   1602_CHUANKOU                                                         06/29/2010 13:27:06 PAGE 1   


C51 COMPILER V8.02, COMPILATION OF MODULE 1602_CHUANKOU
OBJECT MODULE PLACED IN 1602-chuankou.OBJ
COMPILER INVOKED BY: D:\处理软件\keil\C51\BIN\C51.EXE 1602-chuankou.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1           /***************************************************************
   2                                                  “天祥电子”            倾情奉献
   3                                                                  www.txmcu.com
   4                                                                  www.txmcu.cn
   5          *****************************************************************
   6          串行通迅     LCD1602显示                                                        *
   7          * 作者： 郭天祥 (Email: txmcu@163.com)                                  *
   8          * 网站： www.tx-power.com(天祥电子)                                     *
   9          * 邮箱： txmcu@163.com                                                  *
  10          *【版权】Copyright(C)天祥电子 www.tx-power.com  All Rights Reserved     *
  11          *【声明】此程序仅用于学习与参考，引用请注明版权和作者信息！             *
  12          *************************************************************************
  13          * 描述：                                                                *
  14          *   主机发送123456给单片机，单片机接收到数据后发送TX-MCU给主机。        *
  15          *   主机发送其它数据给单片机，单片机接收到数据后，再发送给主机。        *
  16          *   LCD1602显示接收数据的ASCII码。  波特率9600                          *
  17          *   注：当单片机收到数据只有凑够16个时才会一次在液晶上显示出来          *
  18          ************************************************************************/
  19          
  20          #include <reg52.h>
  21          #include <intrins.h>
  22                  
  23          #define uchar  unsigned char 
  24          #define uint   unsigned int
  25          
  26          sbit LCD_RS = P3^5;             
  27          sbit LCD_EN = P3^4;
  28          
  29          #define delayNOP(); {_nop_();_nop_();_nop_();_nop_();};
  30          
  31          
  32          uchar data  RXDdata[ ] = {0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
  33                                    0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20 };
  34          uchar temp,buf,m,count;
  35          
  36          bit   playflag=0;
  37          
  38          uchar code  cdis1[ ] = {" SERILA TRANFER "};
  39          uchar code  cdis2[ ] = {"                "};
  40          
  41          /**********************************************************
  42          
  43           延时子程序
  44          
  45          **********************************************************/
  46          void delay1(uint ms) 
  47          
  48          {
  49   1         uchar k;
  50   1         while(ms--)
  51   1         {
  52   2           for(k = 0; k < 120; k++);
  53   2         }
  54   1      }
  55          
C51 COMPILER V8.02   1602_CHUANKOU                                                         06/29/2010 13:27:06 PAGE 2   

  56          /******************************************************************/
  57          /*                                                                */
  58          /*检查LCD忙状态                                                   */
  59          /*lcd_busy为1时，忙，等待。lcd-busy为0时,闲，可写指令与数据。     */
  60          /*                                                                */
  61          /******************************************************************/ 
  62          bit lcd_busy()
  63           {                          
  64   1          bit result;
  65   1          LCD_RS = 0;
  66   1      //    LCD_RW = 1;
  67   1          LCD_EN = 1;
  68   1          delayNOP();
  69   1          result = (bit)(P0&0x80);
  70   1          LCD_EN = 0;
  71   1          return(result); 
  72   1       }
  73          
  74          /*******************************************************************/
  75          /*                                                                 */
  76          /*写指令数据到LCD                                                  */
  77          /*RS=L，RW=L，E=高脉冲，D0-D7=指令码。                             */
  78          /*                                                                 */
  79          /*******************************************************************/
  80          void lcd_wcmd(uchar cmd)
  81          {                          
  82   1       //  while(lcd_busy());
  83   1          LCD_RS = 0;
  84   1        //  LCD_RW = 0;
  85   1          LCD_EN = 0;
  86   1          _nop_();
  87   1          _nop_(); 
  88   1          P0 = cmd;
  89   1          delayNOP();
  90   1          LCD_EN = 1;
  91   1          delayNOP();
  92   1          LCD_EN = 0;  
  93   1      }
  94          
  95          /*******************************************************************/
  96          /*                                                                 */
  97          /*写显示数据到LCD                                                  */
  98          /*RS=H，RW=L，E=高脉冲，D0-D7=数据。                               */
  99          /*                                                                 */
 100          /*******************************************************************/
 101          void lcd_wdat(uchar dat)
 102          {                          
 103   1      //   while(lcd_busy());
 104   1          LCD_RS = 1;
 105   1        //  LCD_RW = 0;
 106   1          LCD_EN = 0;
 107   1          P0 = dat;
 108   1          delayNOP();
 109   1          LCD_EN = 1;
 110   1          delayNOP();
 111   1          LCD_EN = 0; 
 112   1      }
 113          
 114          /*******************************************************************/
 115          /*                                                                 */
 116          /*  LCD初始化设定                                                  */
 117          /*                                                                 */
C51 COMPILER V8.02   1602_CHUANKOU                                                         06/29/2010 13:27:06 PAGE 3   

 118          /*******************************************************************/
 119          void lcd_init()
 120          { 
 121   1          delay1(15);   
 122   1          lcd_wcmd(0x01);      //清除LCD的显示内容            
 123   1          lcd_wcmd(0x38);      //16*2显示，5*7点阵，8位数据
 124   1          delay1(5);
 125   1          lcd_wcmd(0x38);         
 126   1          delay1(5);
 127   1          lcd_wcmd(0x38);         
 128   1          delay1(5);
 129   1      
 130   1          lcd_wcmd(0x0c);      //开显示，显示光标，光标闪烁
 131   1          delay1(5);
 132   1      
 133   1          lcd_wcmd(0x01);      //清除LCD的显示内容
 134   1          delay1(5);
 135   1      }
 136          
 137          /*******************************************************************/
 138          /*                                                                 */
 139          /*  设定显示位置                                                   */
 140          /*                                                                 */
 141          /*******************************************************************/
 142          
 143          void lcd_pos(uchar pos)
 144          {                          
 145   1        lcd_wcmd(pos | 0x80);  //数据指针=80+地址变量
 146   1      }
 147          
 148          /*********************************************************
 149          
 150            发送数据函数
 151          
 152          *********************************************************/
 153          void senddata(uchar dat)
 154          {
 155   1           SBUF =dat;
 156   1           while(!TI);
 157   1           TI = 0;
 158   1      }
 159          
 160          /*********************************************************
 161          
 162            串行中断服务函数
 163          
 164          *********************************************************/
 165          void  serial() interrupt 4 
 166          {
 167   1         ES = 0;                //关闭串行中断
 168   1         RI = 0;                //清除串行接受标志位
 169   1         buf = SBUF;            //从串口缓冲区取得数据
 170   1           
 171   1         switch(buf)
 172   1         {
 173   2            case 0x31:  senddata('T');break;  //接受到1，发送字符'T'给计算机         
 174   2            case 0x32:  senddata('X');break;  //接受到2，发送字符'X'给计算机       
 175   2            case 0x33:  senddata('-');break;  //接受到3，发送字符'-'给计算机       
 176   2            case 0x34:  senddata('M');break;  //接受到4，发送字符'M'给计算机       
 177   2            case 0x35:  senddata('C');break;  //接受到5，发送字符'C'给计算机           
 178   2            case 0x36:  senddata('U');break;  //接受到5，发送字符'U'给计算机                  
 179   2            default:    senddata(buf);break;  //接受到其它数据，将其发送给计算机         
C51 COMPILER V8.02   1602_CHUANKOU                                                         06/29/2010 13:27:06 PAGE 4   

 180   2         }
 181   1      
 182   1         if(buf!=0x0D)
 183   1         {   
 184   2           if(buf!=0x0A)
 185   2           { 
 186   3             temp =buf;
 187   3             if(count<16)
 188   3             {         
 189   4               RXDdata[count]=temp;
 190   4               count++;
 191   4                       if(count==16)
 192   4                              playflag=1;
 193   4             }
 194   3           } 
 195   2         }
 196   1         ES = 1;    //允许串口中断
 197   1      }
 198          
 199          /*********************************************************
 200          
 201            数据显示函数
 202          
 203          *********************************************************/
 204          void  play()
 205          {
 206   1         if(playflag)
 207   1         { 
 208   2           lcd_pos(0x40);           //设置位置为第二行
 209   2           for(m=0;m<16;m++) 
 210   2           {
 211   3                      lcd_wdat(cdis2[m]);      //清LCD1602第二行
 212   3                      delay1(5);
 213   3               }
 214   2               lcd_pos(0x40);           //设置位置为第二行
 215   2           for(m=0;m<16;m++)
 216   2           {
 217   3          //   lcd_pos(0x40+m);       //设置显示位置为第二行
 218   3             lcd_wdat(RXDdata[m]);  //显示字符 
 219   3                 delay1(5);
 220   3           }
 221   2      
 222   2           playflag=0;              
 223   2           count=0x00;
 224   2      
 225   2           for(m=0;m<16;m++)      
 226   2           {
 227   3                      RXDdata[m]=0x20;         //清显存单元    
 228   3                      delay1(5);
 229   3               }
 230   2         }               
 231   1      }
 232          
 233          /*********************************************************
 234          
 235            主函数
 236          
 237          *********************************************************/
 238          void main(void) 
 239          {
 240   1          P0 = 0xff;
 241   1          P2 = 0xff;         
C51 COMPILER V8.02   1602_CHUANKOU                                                         06/29/2010 13:27:06 PAGE 5   

 242   1          
 243   1          SCON=0x50;           //设定串口工作方式
 244   1          PCON=0x00;           //波特率不倍增
 245   1                              
 246   1          TMOD=0x20;           //定时器1工作于8位自动重载模式, 用于产生波特率
 247   1          EA=1;
 248   1          ES = 1;              //允许串口中断
 249   1          TL1=0xfd;
 250   1          TH1=0xfd;             //波特率9600
 251   1          TR1=1;
 252   1      
 253   1          lcd_init();
 254   1          lcd_pos(0x00);        //设置显示位置为第一行
 255   1          for(m=0;m<16;m++) 
 256   1          {
 257   2                      lcd_wdat(cdis1[m]);   //显示字符
 258   2                      delay1(5);
 259   2              }
 260   1          lcd_pos(0x40);        //设置显示位置为第二行
 261   1          for(m=0;m<16;m++) 
 262   1          {
 263   2                      lcd_wdat(cdis2[m]);   //显示字符            
 264   2                      delay1(5);
 265   2              }
 266   1          while(1)        
 267   1          {
 268   2            play();       
 269   2          }
 270   1      }
 271          
 272          /*********************************************************/ 


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    437    ----
   CONSTANT SIZE    =     34    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     20    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
